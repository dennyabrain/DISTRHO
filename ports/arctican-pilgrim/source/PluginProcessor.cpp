/*
  ==============================================================================

    This file was auto-generated by the Jucer!

    It contains the basic startup code for a Juce application.

  ==============================================================================
*/

#include "PluginProcessor.h"
#include "PluginEditor.h"


//==============================================================================
ThePilgrimAudioProcessor::ThePilgrimAudioProcessor()
{
	filterFreq=0.5;
	samplesInBlock=0;
	globalSampleRate=0.0;
	mixAmount=1.0;
	currentPreset=0;
}

ThePilgrimAudioProcessor::~ThePilgrimAudioProcessor()
{
}

//==============================================================================
const String ThePilgrimAudioProcessor::getName() const
{
    return JucePlugin_Name;
}

int ThePilgrimAudioProcessor::getNumParameters()
{
    return totalNumParams;
}

float ThePilgrimAudioProcessor::getParameter (int index)
{
    switch (index)
    {
        case filterFreqParam:		return filterFreq;
		case mixParam:				return mixAmount;

        default:            return 0.0f;
    }
}

void ThePilgrimAudioProcessor::setParameter (int index, float newValue)
{
	switch (index)
    {
        case filterFreqParam:		
			{
				filterFreq = newValue; 
				filterChanged();
				break;
			}
        case mixParam:				mixAmount = newValue;  break;

        default:            break;
    }
}

const String ThePilgrimAudioProcessor::getParameterName (int index)
{

	switch (index)
    {
        case filterFreqParam:		return "Frequency";
        case mixParam:				return "Mix";

        default:            break;
    }
    return String::empty;
}

const String ThePilgrimAudioProcessor::getParameterText (int index)
{
    return String (getParameter (index), 2);
}

const String ThePilgrimAudioProcessor::getInputChannelName (int channelIndex) const
{
    return String (channelIndex + 1);
}

const String ThePilgrimAudioProcessor::getOutputChannelName (int channelIndex) const
{
    return String (channelIndex + 1);
}

bool ThePilgrimAudioProcessor::isInputChannelStereoPair (int index) const
{
    return true;
}

bool ThePilgrimAudioProcessor::isOutputChannelStereoPair (int index) const
{
    return true;
}

bool ThePilgrimAudioProcessor::acceptsMidi() const
{
#if JucePlugin_WantsMidiInput
    return true;
#else
    return false;
#endif
}

bool ThePilgrimAudioProcessor::producesMidi() const
{
#if JucePlugin_ProducesMidiOutput
    return true;
#else
    return false;
#endif
}

int ThePilgrimAudioProcessor::getNumPrograms()
{
    return 5;
}

int ThePilgrimAudioProcessor::getCurrentProgram()
{
    return currentPreset;
}

void ThePilgrimAudioProcessor::setCurrentProgram (int index)
{
	if((Time::getMillisecondCounter()-timeSinceChunkCalled)<200) // Thanks to "valhallasound" from the JUCE forum for this tip! :)
      return;

	switch(index)
	{
	case 0:
	  filterFreq = 0.5f;
	  mixAmount = 1.0f;
	  currentPreset = 0;
	break;
	case 1:
	  filterFreq = 0.6f;
	  mixAmount = 1.0f;
	  currentPreset = 1;
	break;
	case 2:
	  filterFreq = 0.4f;
	  mixAmount = 1.0f;
	  currentPreset = 2;
	break;
	case 3:
	  filterFreq = 0.6f;
	  mixAmount = 0.5f;
	  currentPreset = 3;
	break;
	case 4:
	  filterFreq = 0.4f;
	  mixAmount = 0.5f;
	  currentPreset = 4;
	break;
	}
	filterChanged();
}

const String ThePilgrimAudioProcessor::getProgramName (int index)
{
	switch(index)
	{
		case 0:
			return "All Pass";
			break;
		case 1:
			return "Bass Cut";
			break;
		case 2:
			return "Treble Cut";
			break;
		case 3:
			return "Bass Attenuator";
			break;
		case 4:
			return "Treble Attenuator";
			break;
		default:
			return "This isn't a preset";
			break;
	}
}

void ThePilgrimAudioProcessor::changeProgramName (int index, const String& newName)
{
}

//==============================================================================
void ThePilgrimAudioProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)
{
    // Use this method as the place to do any pre-playback
    // initialisation that you need..

	samplesInBlock = samplesPerBlock;
	globalSampleRate = sampleRate;
	filterChanged();
	lowFilterL.reset();
	lowFilterR.reset();
	highFilterL.reset();
	highFilterR.reset();
}

void ThePilgrimAudioProcessor::releaseResources()
{
    // When playback stops, you can use this as an opportunity to free up any
    // spare memory, etc.
}

void ThePilgrimAudioProcessor::processBlock (AudioSampleBuffer& buffer, MidiBuffer& midiMessages)
{
    // This is the place where you'd normally do the guts of your plugin's
    // audio processing...

	// Dry Buffer
	AudioSampleBuffer dryBuffer = buffer;

    for (int channel = 0; channel < getNumInputChannels(); ++channel)
    {
        float* channelData = buffer.getSampleData (channel);
        float* dryData = dryBuffer.getSampleData (channel);
		
		if (channel == 0)
		{
				lowFilterL.processSamples(channelData, buffer.getNumSamples());
				highFilterL.processSamples(channelData, buffer.getNumSamples());
		}
		else if (channel == 1)
		{
				lowFilterR.processSamples(channelData, buffer.getNumSamples());
				highFilterR.processSamples(channelData, buffer.getNumSamples());
		}
		
		for (int i = 0; i < buffer.getNumSamples(); ++i)
		{
			channelData[i] = (channelData[i] * mixAmount) + (dryData[i] * ((mixAmount - 1) * -1.0));
		}
    }


    // In case we have more outputs than inputs, we'll clear any output
    // channels that didn't contain input data, (because these aren't
    // guaranteed to be empty - they may contain garbage).
    for (int i = getNumInputChannels(); i < getNumOutputChannels(); ++i)
    {
        buffer.clear (i, 0, buffer.getNumSamples());
    }
}

//==============================================================================
bool ThePilgrimAudioProcessor::hasEditor() const
{
    return true; // (change this to false if you choose to not supply an editor)
}

AudioProcessorEditor* ThePilgrimAudioProcessor::createEditor()
{
    return new ThePilgrimAudioProcessorEditor (this);
}

//==============================================================================
void ThePilgrimAudioProcessor::getStateInformation (MemoryBlock& destData)
{
    // You should use this method to store your parameters in the memory block.
    // You could do that either as raw data, or use the XML or ValueTree classes
    // as intermediaries to make it easy to save and load complex data.
	// Create an outer XML element..
    XmlElement xml ("MYPLUGINSETTINGS");

    // add some attributes to it..
   // xml.setAttribute ("uiWidth", lastUIWidth);
   // xml.setAttribute ("uiHeight", lastUIHeight);
    //xml.setAttribute ("gain", gain);
   // xml.setAttribute ("delay", delay);
	xml.setAttribute ("freq", filterFreq);
	xml.setAttribute ("mix", mixAmount);


    // then use this helper function to stuff it into the binary blob and return it..
    copyXmlToBinary (xml, destData);


}

void ThePilgrimAudioProcessor::setStateInformation (const void* data, int sizeInBytes)
{
    // You should use this method to restore your parameters from this memory block,
    // whose contents will have been created by the getStateInformation() call.

	timeSinceChunkCalled = Time::getMillisecondCounter();

	ScopedPointer<XmlElement> xmlState (getXmlFromBinary (data, sizeInBytes));

    if (xmlState != 0)
    {
        // make sure that it's actually our type of XML object..
        if (xmlState->hasTagName ("MYPLUGINSETTINGS"))
        {
            // ok, now pull out our parameters..
           // gain  = xmlState->getIntAttribute ("gain", gain);
            //lastUIHeight = xmlState->getIntAttribute ("uiHeight", lastUIHeight);

            filterFreq  = (float) xmlState->getDoubleAttribute ("freq", filterFreq);
            mixAmount  = (float) xmlState->getDoubleAttribute ("mix", mixAmount);

        }
	}
}

//==============================================================================
// This creates new instances of the plugin..
AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new ThePilgrimAudioProcessor();
}


void ThePilgrimAudioProcessor::filterChanged(void)
{
	if (filterFreq <= 0.5)
	{
		double newFilterFreq = filterFreq * 2.0;						// Scale 0.0-0.5 to 0-1
		newFilterFreq = newFilterFreq * newFilterFreq * newFilterFreq;	// Cube values for smoother control
		newFilterFreq  = (newFilterFreq * 19940.0) + 60;				// Scale to 60Hz to 20000Hz LOWPASS
		lowFilterL.makeLowPass(globalSampleRate, newFilterFreq);
		lowFilterR.makeLowPass(globalSampleRate, newFilterFreq);
		highFilterL.makeHighPass(globalSampleRate, 20.0);
		highFilterR.makeHighPass(globalSampleRate, 20.0);
	}
	else if (filterFreq > 0.5)
	{
		double newFilterFreq = (filterFreq - 0.5) * 2.0;				// Scale 0.5-1.0 to 0-1
		newFilterFreq = newFilterFreq * newFilterFreq * newFilterFreq;	// Cube values for smoother control
		newFilterFreq = (newFilterFreq * 18980.0) + 20;					// 20Hz to 19000Hz HIGHPASS
		highFilterL.makeHighPass(globalSampleRate, newFilterFreq);
		highFilterR.makeHighPass(globalSampleRate, newFilterFreq);
		lowFilterL.makeLowPass(globalSampleRate, 20000.0);
		lowFilterR.makeLowPass(globalSampleRate, 20000.0);
	}
}