/*
  ==============================================================================

    This file was auto-generated by the Jucer!

    It contains the basic startup code for a Juce application.

  ==============================================================================
*/

#include "PluginProcessor.h"
#include "PluginEditor.h"


//==============================================================================
ThePilgrimAudioProcessor::ThePilgrimAudioProcessor()
{
	learnIsActive=0;
	currentLearnParam=0;
	contnumber=0;
	contvalue=0;
	lastMovedParam=0;
}

ThePilgrimAudioProcessor::~ThePilgrimAudioProcessor()
{
}

//==============================================================================
const String ThePilgrimAudioProcessor::getName() const
{
    return JucePlugin_Name;
}

int ThePilgrimAudioProcessor::getNumParameters()
{
    return totalNumParams;
}

float ThePilgrimAudioProcessor::getParameter (int index)
{
	if (index == 0)
		return filterParameter.getValue();
	else if (index == 1)
		return mixParameter.getValue();
	return 0.0f;
}

void ThePilgrimAudioProcessor::setParameter (int index, float newValue)
{
	if (index == filterFreqParam)
		filterParameter.setValue(newValue);
	else if (index == mixParam)
		mixParameter.setValue(newValue);
}

const String ThePilgrimAudioProcessor::getParameterName (int index)
{
	if (index == filterFreqParam)
		return "Filter Freq";
	else if (index == mixParam)
		return "Mix";
    return String::empty;
}

const String ThePilgrimAudioProcessor::getParameterText (int index)
{
	String output;
	double newFilterFreq;
        double smoothValue = filterParameter.getSmoothedValue();

	if (index == 0) {

		if (smoothValue <= 0.5)
		{
			newFilterFreq = filterParameter.getValue() * 2.0;						// Scale 0.0-0.5 to 0-1
			newFilterFreq = newFilterFreq * newFilterFreq * newFilterFreq;	// Cube values for smoother control
			newFilterFreq  = (newFilterFreq * 19940.0) + 60;				// Scale to 60Hz to 20000Hz LOWPASS
		}
		else
		{
			newFilterFreq = (filterParameter.getValue() - 0.5) * 2.0;				// Scale 0.5-1.0 to 0-1
			newFilterFreq = newFilterFreq * newFilterFreq * newFilterFreq;	// Cube values for smoother control
			newFilterFreq = (newFilterFreq * 18980.0) + 20;					// 20Hz to 19000Hz HIGHPASS
		}

		output = String(newFilterFreq)+"Hz";
		return output;
	}
	else if (index == 1)
	{
		int percent = (int(mixParameter.getValue()) * 100);
		output = String(percent)+"%";
		return output;
	}
    return String::empty;
}

const String ThePilgrimAudioProcessor::getInputChannelName (int channelIndex) const
{
    return String (channelIndex + 1);
}

const String ThePilgrimAudioProcessor::getOutputChannelName (int channelIndex) const
{
    return String (channelIndex + 1);
}

bool ThePilgrimAudioProcessor::isInputChannelStereoPair (int index) const
{
    return true;
}

bool ThePilgrimAudioProcessor::isOutputChannelStereoPair (int index) const
{
    return true;
}

bool ThePilgrimAudioProcessor::acceptsMidi() const
{
#if JucePlugin_WantsMidiInput
    return true;
#else
    return false;
#endif
}

bool ThePilgrimAudioProcessor::producesMidi() const
{
#if JucePlugin_ProducesMidiOutput
    return true;
#else
    return false;
#endif
}

int ThePilgrimAudioProcessor::getNumPrograms()
{
    return 0;
}

int ThePilgrimAudioProcessor::getCurrentProgram()
{
    return 0;
}

void ThePilgrimAudioProcessor::setCurrentProgram (int index)
{
}

const String ThePilgrimAudioProcessor::getProgramName (int index)
{
    return String("Default");
}

void ThePilgrimAudioProcessor::changeProgramName (int index, const String& newName)
{
}

//==============================================================================
void ThePilgrimAudioProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)
{
    // Use this method as the place to do any pre-playback
    // initialisation that you need..
	globalSampleRate=sampleRate;
	updateFilter();
	lowFilterL.reset();
	lowFilterR.reset();
	highFilterL.reset();
	highFilterR.reset();

}

void ThePilgrimAudioProcessor::releaseResources()
{
    // When playback stops, you can use this as an opportunity to free up any
    // spare memory, etc.
}

void ThePilgrimAudioProcessor::processBlock (AudioSampleBuffer& buffer, MidiBuffer& midiMessages)
{

	MidiMessage message;
	MidiBuffer::Iterator i (midiMessages);
	int messageFrameRelativeTothisProcess;
	while (i.getNextEvent (message, messageFrameRelativeTothisProcess))
	{
		if (message.isController() == true)
		{



			// Get values
			contnumber = message.getControllerNumber();
			contvalue = message.getControllerValue();


			// Live Mode
			if (learnIsActive == false)
			{
				// Update Parameter
				if (contnumber == filterParameter.getControllerNumber())
					setParameter(filterFreqParam, (float(contvalue) / 127.0) );
				else if (contnumber == mixParameter.getControllerNumber())
					setParameter(mixParam, (float(contvalue) / 127.0) );
			}

			// Learn Mode
			if (learnIsActive == true)
			{
				if (currentLearnParam == 0)
				{
					filterParameter.setControllerNumber(contnumber);
				}
				else if (currentLearnParam == 1)
				{
					mixParameter.setControllerNumber(contnumber);
				}
			}

		}




   }


		//bool isController() const noexcept;

   // int getControllerNumber() const noexcept;
// get Controller name

   // int getControllerValue() const noexcept;



	// TIDY UP THIS SO ANY VALUE WORKS
	int samplesUntilSmooth = 8;
	int currentSmoothSample = 0;
	int smoothSampleWas = 0;

    // This is the place where you'd normally do the guts of your plugin's
    // audio processing...

	// The 'for' loop cycles through each channel at a time.
    for (int channel = 0; channel < getNumInputChannels(); ++channel)
    {
        float* channelData = buffer.getSampleData (channel);
		AudioSampleBuffer dryBuffer = buffer;
        float* dryData = dryBuffer.getSampleData (channel);

			for (int i = 0; i < buffer.getNumSamples(); ++i)
			{

			// Smoother //
				currentSmoothSample++;
				if (currentSmoothSample>samplesUntilSmooth) {
					filterParameter.smooth();
					mixParameter.smooth();
					currentSmoothSample=currentSmoothSample-samplesUntilSmooth;
					updateFilter();
				}
			//////////////


				// Filter Channels
				if (channel == 0){
					channelData[i] = lowFilterL.processSingleSampleRaw(channelData[i]);
					channelData[i] = highFilterL.processSingleSampleRaw(channelData[i]);}
				else if (channel == 1){
					channelData[i] = lowFilterR.processSingleSampleRaw(channelData[i]);
					channelData[i] = highFilterR.processSingleSampleRaw(channelData[i]);}
				//////////////////

				// Mix (Wet/Dry)
				channelData[i] = (channelData[i] * mixParameter.getSmoothedValue()) + (dryData[i] * ((mixParameter.getSmoothedValue() - 1) * -1.0));
				/////

					//channelData[i] = channelData[i] * filterParameter.getSmoothedValue();
			}

		currentSmoothSample=smoothSampleWas;

    }

    // In case we have more outputs than inputs, we'll clear any output
    // channels that didn't contain input data, (because these aren't
    // guaranteed to be empty - they may contain garbage).
    for (int i = getNumInputChannels(); i < getNumOutputChannels(); ++i)
    {
        buffer.clear (i, 0, buffer.getNumSamples());
    }
}

void ThePilgrimAudioProcessor::updateFilter()
{
	double filterFreq = double(filterParameter.getSmoothedValue());

	if (filterParameter.getSmoothedValue() <= 0.5)
	{
		double newFilterFreq = filterFreq * 2.0;						// Scale 0.0-0.5 to 0-1
		newFilterFreq = newFilterFreq * newFilterFreq * newFilterFreq;	// Cube values for smoother control
		newFilterFreq  = (newFilterFreq * 19940.0) + 60;				// Scale to 60Hz to 20000Hz LOWPASS
		lowFilterL.makeLowPass(globalSampleRate, newFilterFreq);
		lowFilterR.makeLowPass(globalSampleRate, newFilterFreq);
		highFilterL.makeHighPass(globalSampleRate, 20.0);
		highFilterR.makeHighPass(globalSampleRate, 20.0);
	}
	else if (filterParameter.getSmoothedValue() > 0.5)
	{
		double newFilterFreq = (filterFreq - 0.5) * 2.0;				// Scale 0.5-1.0 to 0-1
		newFilterFreq = newFilterFreq * newFilterFreq * newFilterFreq;	// Cube values for smoother control
		newFilterFreq = (newFilterFreq * 18980.0) + 20;					// 20Hz to 19000Hz HIGHPASS
		highFilterL.makeHighPass(globalSampleRate, newFilterFreq);
		highFilterR.makeHighPass(globalSampleRate, newFilterFreq);
		lowFilterL.makeLowPass(globalSampleRate, 20000.0);
		lowFilterR.makeLowPass(globalSampleRate, 20000.0);
	}

}

//==============================================================================
bool ThePilgrimAudioProcessor::hasEditor() const
{
    return true; // (change this to false if you choose to not supply an editor)
}

AudioProcessorEditor* ThePilgrimAudioProcessor::createEditor()
{
    return new ThePilgrimAudioProcessorEditor (this);
}

//==============================================================================
void ThePilgrimAudioProcessor::getStateInformation (MemoryBlock& destData)
{
    // You should use this method to store your parameters in the memory block.
    // You could do that either as raw data, or use the XML or ValueTree classes
    // as intermediaries to make it easy to save and load complex data.
	// Create an outer XML element..
    XmlElement xml ("MYPLUGINSETTINGS");

    // add some attributes to it..
	// xml.setAttribute ("uiWidth", lastUIWidth);
	// xml.setAttribute ("uiHeight", lastUIHeight);
    //xml.setAttribute ("gain", gain);
	// xml.setAttribute ("delay", delay);
	xml.setAttribute ("freq", filterParameter.getValue());
	xml.setAttribute ("mix", mixParameter.getValue());
	xml.setAttribute ("freqCC", filterParameter.getControllerNumber());
	xml.setAttribute ("mixCC", mixParameter.getControllerNumber());

    // then use this helper function to stuff it into the binary blob and return it..
    copyXmlToBinary (xml, destData);
}

void ThePilgrimAudioProcessor::setStateInformation (const void* data, int sizeInBytes)
{
    // You should use this method to restore your parameters from this memory block,
    // whose contents will have been created by the getStateInformation() call.

	//timeSinceChunkCalled = Time::getMillisecondCounter();

	ScopedPointer<XmlElement> xmlState (getXmlFromBinary (data, sizeInBytes));

    if (xmlState != 0)
    {
        // make sure that it's actually our type of XML object..
        if (xmlState->hasTagName ("MYPLUGINSETTINGS"))
        {
            // ok, now pull out our parameters..
			// gain  = xmlState->getIntAttribute ("gain", gain);
            //lastUIHeight = xmlState->getIntAttribute ("uiHeight", lastUIHeight);

            filterParameter.setValue((float) xmlState->getDoubleAttribute ("freq", 0));
            mixParameter.setValue((float) xmlState->getDoubleAttribute ("mix", 0));
            filterParameter.setControllerNumber((float) xmlState->getDoubleAttribute ("freqCC", 0));
            mixParameter.setControllerNumber((float) xmlState->getDoubleAttribute ("mixCC", 0));

        }
	}
}

String ThePilgrimAudioProcessor::getStateInformationString ()
{
    XmlElement xml ("MYPLUGINSETTINGS");

    //xml.setAttribute ("freq", filterParameter.getValue());
    //xml.setAttribute ("mix", mixParameter.getValue());
    xml.setAttribute ("freqCC", filterParameter.getControllerNumber());
    xml.setAttribute ("mixCC", mixParameter.getControllerNumber());

    return xml.createDocument (String::empty);
}

void ThePilgrimAudioProcessor::setStateInformationString (const String& data)
{
    XmlElement* const xmlState = XmlDocument::parse(data);

    if (xmlState != 0)
    {
        // make sure that it's actually our type of XML object..
        if (xmlState->hasTagName ("MYPLUGINSETTINGS"))
        {
            //filterParameter.setValue((float) xmlState->getDoubleAttribute ("freq", 0));
            //mixParameter.setValue((float) xmlState->getDoubleAttribute ("mix", 0));
            filterParameter.setControllerNumber((float) xmlState->getDoubleAttribute ("freqCC", 0));
            mixParameter.setControllerNumber((float) xmlState->getDoubleAttribute ("mixCC", 0));
        }
    }
}

//==============================================================================
// This creates new instances of the plugin..
AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new ThePilgrimAudioProcessor();
}
